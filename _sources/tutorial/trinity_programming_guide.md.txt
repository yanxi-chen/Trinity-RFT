# Trinity-RFT Developer Guide

This guide will introduce how to add new task types to Trinity-RFT and provide relevant development guidelines.

> **Note**: Trinity-RFT is still under development, and the following interfaces may change. Please read this section in conjunction with the latest code.

---

## Creating New Task Types

Trinity-RFT supports developers in registering new task types (e.g., multi-round interaction scenarios). Below are the steps for creating a new task type.

---

### Step 0: Basic Concepts

Before starting development, it's important to understand several core concepts:

- **Task**: Represents a data structure that can be converted into a `Workflow`. The `Task` data format may vary significantly depending on the type of task:
  - **Math problems**: `Task` contains the problem description and the standard answer.
  - **Programming scenarios**: `Task` includes the problem description, test cases, runtime environment, and other complex information.

- **Workflow**: Can be understood as the running state of a `Task`, defining the interaction flow between Agents and Environments, including logic similar to _Rollout_ and _Reward_ calculations in other frameworks. After execution, it generates `Experience`. Trinity-RFT has several built-in `Workflows`:
  - `MathWorkflow`: For math scenarios, submits problems to LLM, parses results, and calculates scores (rewards).
  - `CodeWorkflow` (Coming soon): For coding scenarios, executes returned code, runs tests, and calculates rewards based on test results.
  - ...

- **Experience**: The output of running a `Workflow`, where the internal data format depends on the algorithm used for training. For example, for common PPO/GRPO algorithms, `Experience` includes lists of token_ids, action_mask (identifying which tokens were generated by the LLM), logprobs, rewards, etc.

---

### Step 1: Prepare Task Dataset

Each `Task` is a Python dictionary (`Dict[str, Any]`), containing various parameters needed to initialize the `Workflow`. Due to significant differences in initialization parameters across different `Workflows`, the following example uses a math problem scenario.

In the math problem scenario, the `Task` dataset can be a `jsonl` file, where each lineâ€™s JSON contains `question` and `answer` fields representing the problem description and standard answer, respectively.

```json
{"question": "1+1=", "answer": "2"}
{"question": "2+2=", "answer": "4"}
...
```

---

### Step 2: Write Workflow

The core of creating a new task type is writing a new `Workflow`, whose base class interface is as follows:

```python
from abc import ABC
from typing import List

class Workflow(ABC):

    def __init__(self, model: ModelWrapper, **kwargs):
        self.model = model

    @abstractmethod
    def run(self) -> List[Experience]:
        """Run the workflow and return a list of Experiences."""
```

Developers can register their own `Workflow` through the `WORKFLOWS.register_module` method, but need to ensure that the name does not conflict with existing `Workflows`.

#### Initialization Parameters
When initializing, `Workflow` receives the following parameters:
- `model`: Provides an API call interface similar to OpenAI, capable of receiving a list of conversation messages and returning content generated by the LLM (including reply text `response_text`, full sequence token ids `tokens`, prompt part token length `prompt_length`, and a list of output token logprobs `logprobs`).
- `kwargs`: Reads one line of data from the `Task` dataset, allowing developers to initialize internal modules such as Agent and Environment within the `Workflow` based on these parameters.

#### Example Code
Below is a simple example demonstrating how to implement a math problem `Workflow`:

```python
@WORKFLOWS.register_module("example_workflow")
class ExampleWorkflow(Workflow):

    def __init__(self, model: ModelWrapper, **kwargs):
        super().__init__(model)
        self.question = kwargs.get("question")
        self.answer = kwargs.get("answer")

    def run(self) -> List[Experience]:
        response = self.model.chat(
            [
                {
                    "role": "user",
                    "content": f"Question:\n{self.question}",
                }
            ]
        )
        reward: float = calculate_reward(response.response_text, self.answer)
        return [Experience(
            tokens=response.tokens,
            prompt_length=response.prompt_length,
            reward=reward,
            logprobs=response.logprobs,
        )]
```

---

### Step 3: Modify Configuration File

After completing the development of the `Workflow`, you need to modify the configuration file to set the `default_workflow_type` in the `buffer.explorer_input` domain to the newly registered `Workflow` name.

```yaml
buffer:
  # Other fields
  explorer_input:
    taskset:
      name: taskset_name
      path: 'path/to/taskset'
        # Other fields
    eval_tasksets: []
    default_workflow_type: example_workflow
# Other fields
```

---

## Check Code Style

Before submitting the code, make sure it passes the code style check. Follow these steps:

```shell
# Install code style checking tools
cd <path_to_trinity_rft>
# bash
pip install -e .[dev]
# zsh
# pip install -e .\[dev\]

# Run code style checks
pre-commit --all-files

# Commit the code after all checks pass
git commit -am "create example workflow"
```
